// Copyright (c) 2019, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

// SpikeNeuron contains state values for spiking activation function
type SpikeNeuron struct {
	ISI    float32 `desc:"inter-spike-interval -- counts up since last spike"`
	AvgISI float32 `desc:"average inter-spike-interval -- average time interval between spikes"`
}

func (sn *SpikeNeuron) InitAct() {
	sn.ISI = -1    // hasn't spiked yet
	sn.AvgISI = -1 // hasn't spiked yet
}

// SpikeParams contains spiking activation function params.
// Implements the AdEx adaptive exponential function
type Spike struct {
	Thr      float32 `def:"0.5" desc:"membrane potential threshold for actually triggering a spike when NOT using the exponential mechanism -- this value also enters into the exponential mechanism too -- see also ExpThr"`
	Exp      bool    `def:"false" desc:"if true, turn on exponential excitatory current that drives Vm rapidly upward for spiking as it gets past its nominal firing threshold (Thr) -- nicely captures the Hodgkin Huxley dynamics of Na and K channels -- uses Brette & Gurstner 2005 AdEx formulation -- this mechanism has an unfortunate interaction with the continuous inhibitory currents generated by the standard FFFB inhibitory function, which cause this mechanism to desensitize and fail to spike"`
	ExpSlope float32 `viewif:"Exp" def:"0.02" desc:"slope in Vm (2 mV = .02 in normalized units) for extra exponential excitatory current that drives Vm rapidly upward for spiking as it gets past its nominal firing threshold (Thr) -- nicely captures the Hodgkin Huxley dynamics of Na and K channels -- uses Brette & Gurstner 2005 AdEx formulation -- a value of 0 disables this mechanism"`
	ExpThr   float32 `viewif:"Exp" def:"1.2" desc:"membrane potential threshold for actually triggering a spike when using the exponential mechanism"`
	VmR      float32 `def:"0.3;0;0.15" desc:"post-spiking membrane potential to reset to, produces refractory effect if lower than VmInit -- 0.30 is apropriate biologically-based value for AdEx (Brette & Gurstner, 2005) parameters"`
	Tr       int     `def:"3" desc:"post-spiking explicit refractory period, in cycles -- prevents Vm updating for this number of cycles post firing"`
	MaxHz    float32 `def:"180" min:"1" desc:"for translating spiking interval (rate) into rate-code activation equivalent (and vice-versa, for clamped layers), what is the maximum firing rate associated with a maximum activation value (max act is typically 1.0 -- depends on act_range)"`
	RateTau  float32 `def:"5" min:"1" desc:"constant for integrating the spiking interval in estimating spiking rate"`
	RateDt   float32 `view:"-" desc:"rate = 1 / tau"`
}

func (sk *Spike) Defaults() {
	sk.Thr = 0.5
	sk.Exp = false
	sk.ExpSlope = 0.02
	sk.ExpThr = 1.2
	sk.VmR = 0.3
	sk.Tr = 3
	sk.MaxHz = 180
	sk.RateTau = 5
	sk.Update()
}

func (sk *Spike) Update() {
	sk.RateDt = 1 / sk.RateTau
}

// ActToInterval compute spiking interval from a given rate-coded activation,
// based on time increment (.001 = 1msec default), Act.Dt.Integ
func (sk *Spike) ActToInterval(act, timeInc, integ float32) float32 {
	if act == 0 {
		return 0
	}
	return (1 / (timeInc * integ * act * sk.MaxHz))
}

// ActFmInterval computes rate-code activation from estimated spiking interval
func (sk *Spike) ActFmInterval(isi, timeInc, integ float32) float32 {
	if isi <= 0 {
		return 0
	}
	maxInt := 1 / (timeInc * integ * sk.MaxHz) // interval at max hz..
	return maxInt / isi                        // normalized
}

// AvgISIFmInternval updates spiking ISI from current interval value
func (sk *Spike) AvgISIFmInterval(avg *float32, isi float32) {
	if *avg <= 0 {
		*avg = isi
	} else if isi < 0.8**avg {
		*avg = isi // if significantly less than we take that
	} else { // integrate on slower
		*avg += sk.RateDt * (isi - *avg) // running avg updt
	}
}

/*
// InetFmG computes net current from conductances and Vm
func (ac *ActParams) InetFmG(vm, ge, gi, gk float32) float32 {
	return ge*(ac.Erev.E-vm) + ac.Gbar.L*(ac.Erev.L-vm) + gi*(ac.Erev.I-vm) + gk*(ac.Erev.K-vm)
}

// VmFmG computes membrane potential Vm from conductances Ge and Gi.
// The Vm value is only used in pure rate-code computation within the sub-threshold regime
// because firing rate is a direct function of excitatory conductance Ge.
func (ac *ActParams) VmFmG(nrn *Neuron) {
	ge := nrn.Ge * ac.Gbar.E
	gi := nrn.Gi * ac.Gbar.I
	nrn.Inet = ac.InetFmG(nrn.Vm, ge, gi, 0)
	nwVm := nrn.Vm + ac.Dt.VmDt*nrn.Inet

	if ac.Noise.Type == VmNoise {
		nwVm += nrn.Noise
	}
	nrn.Vm = ac.VmRange.ClipVal(nwVm)
}

*/

/*

  INLINE virtual void Compute_RateCodeSpike(LEABRA_UNIT_STATE* u, LEABRA_NETWORK_STATE* net, int thr_no) {
    // use act_nd here so it isn't a self-fulfilling function!
    // note: this is only used for clamped layers -- dynamic layers use SPIKE-based mechanisms
    u->spike = 0.0f;
    if(u->act_nd <= opt_thresh.send) { // no spiking below threshold..
      u->spk_t = -1;
      return;
    }
    if(u->spk_t < 0) {            // start counting from first time above threshold
      u->spk_t = net->tot_cycle;
      return;
    }
    int interval = spike.ActToInterval(net->times.time_inc, dt.integ, u->act_nd);
    if((net->tot_cycle - u->spk_t) >= interval) {
      u->spike = 1.0f;
      u->v_m = spike_misc.vm_r;   // reset vm when we spike -- now we can use it just like spiking!
      u->spk_t = net->tot_cycle;
      u->I_net = 0.0f;
    }
  }
  // #CAT_Activation compute spiking activation (u->spike) based off of rate-code activation value

  INLINE void Compute_ActFun_Spiked(LEABRA_UNIT_STATE* u, LEABRA_NETWORK_STATE* net, int thr_no) {
    u->spike = 1.0f;
    u->v_m = spike_misc.vm_r;
    u->I_net = 0.0f;
    if(u->spk_t > 0) {
      float cur_int = net->tot_cycle - u->spk_t;
      spike.UpdateSpikeInterval(u->spike_isi, cur_int);
    }
    u->spk_t = net->tot_cycle;
  }
  // #IGNORE what to do when a spike has been triggered -- common between rate and spike

  INLINE void Compute_ActFun_NotSpiked(LEABRA_UNIT_STATE* u, LEABRA_NETWORK_STATE* net, int thr_no) {
    u->spike = 0.0f;
    if(u->spk_t > 0 && u->spike_isi > 0.0f) {
      float cur_int = net->tot_cycle - u->spk_t;
      if(cur_int > 1.2f * u->spike_isi) { // some kind of estimate of when it exceeds est
        spike.UpdateSpikeInterval(u->spike_isi, cur_int);
      }
    }
  }
  // #IGNORE what to do when a spike has NOT been triggered

  INLINE virtual void Compute_ActFun_Spike(LEABRA_UNIT_STATE* u, LEABRA_NETWORK_STATE* net, int thr_no) {
    if(u->v_m > spike_misc.eff_spk_thr) {
      u->act = 1.0f;
      Compute_ActFun_Spiked(u, net, thr_no);
    }
    else {
      u->act = 0.0f;
      Compute_ActFun_NotSpiked(u, net, thr_no);
    }
    float act_nd = spike.ActFromInterval(u->spike_isi, net->times.time_inc, dt.integ);
    act_nd = act_range.Clip(act_nd);
    act_nd = u->act_nd + dt.vm_dt * (act_nd - u->act_nd); // time integral
    u->da = act_nd - u->act_nd;   // da is on equilibrium activation
    u->act_nd = act_nd;
    if(stp.on) {
      u->act *= u->syn_tr;
      u->act_eq = u->syn_tr * u->act_nd; // act_eq is depressed rate code
    }
    else {
      u->act_eq = u->act_nd;      // eq = nd
    }
  }
  // #CAT_Activation compute the activation from membrane potential -- discrete spiking

  INLINE virtual void Compute_Act_Spike(LEABRA_UNIT_STATE* u, LEABRA_NETWORK_STATE* net, int thr_no) {
    LEABRA_LAYER_STATE* lay = u->GetOwnLayer(net);

    SaveGatingAct(u, net, thr_no);
    // if(syn_delay.on && !u->act_buf) Init_ActBuff(u);

    if(deep.on) {
      Compute_DeepMod(u, net, thr_no);
    }

    if((net->cycle >= 0) && lay->hard_clamped) {
      Compute_ClampSpike(u, net, thr_no, u->ext * spike_misc.clamp_max_p);
      // u->AddToActBuf(syn_delay);
      return; // don't re-compute
    }

    // first, apply inhibition
    LEABRA_UNGP_STATE* ugs = (LEABRA_UNGP_STATE*)u->GetOwnUnGp(net);
    Compute_ApplyInhib(u, net, thr_no, lay, ugs->i_val.g_i);

    Compute_Vm(u, net, thr_no);
    Compute_ActFun_Spike(u, net, thr_no);
    Compute_SelfReg_Cycle(u, net, thr_no);

    // u->AddToActBuf(syn_delay);
  }
  // #CAT_Activation Spiking activation

void LEABRA_UNIT_SPEC::Compute_Vm(LEABRA_UNIT_STATE* u, LEABRA_NETWORK_STATE* net, int thr_no) {
  if(act_fun == SIGMOID) {
    return;
  }
  bool updt_spk_vm = true;
  if(spike_misc.t_r > 0 && u->spk_t > 0) {
    int spkdel = net->tot_cycle - u->spk_t;
    if(spkdel >= 0 && spkdel <= spike_misc.t_r)
      updt_spk_vm = false;    // don't update the spiking vm during refract
  }

  if(net->cycle < dt.fast_cyc) {
    // directly go to equilibrium value
    float new_v_m = Compute_EqVm(u);
    float I_net = new_v_m - u->v_m; // time integrate: not really I_net but hey
    u->v_m += I_net;
    u->v_m_eq = u->v_m;
    u->I_net = I_net;
  }
  else {
    const float net_eff = u->net * g_bar.e;
    const float gc_i = u->gc_i * g_bar.i;
    const float gc_k = g_bar.k * (u->gc_kna_f + u->gc_kna_m + u->gc_kna_s);
    if(updt_spk_vm) { // first compute v_m, using midpoint method:
      float v_m = u->v_m;
      float I_net = 0.0f;
      for(int ti=0; ti < dt.vm_cyc; ti++) {
        float v_m_eff = v_m;
        // midpoint method: take a half-step:
        float I_net_1 = Compute_INet_impl(u, v_m_eff, net_eff, gc_i, gc_k);
        v_m_eff += .5f * dt.integ * dt.vm_dt_cyc * I_net_1; // go half way
        float I_net_2 = Compute_INet_impl(u, v_m_eff, net_eff, gc_i, gc_k);
        // add spike current if relevant
        if((act_fun == SPIKE) && spike_misc.ex) {
          I_net_2 += g_bar.l * spike_misc.exp_slope *
            expf((v_m_eff - act.thr) / spike_misc.exp_slope); // todo: exp_fast
        }
        v_m += dt.integ * dt.vm_dt_cyc * I_net_2;
        I_net += I_net_2;
      }
      u->v_m = v_m;
      u->I_net = I_net;
    }
    // always compute v_m_eq with simple integration -- used for rate code subthreshold
    float I_net_r = Compute_INet_impl(u, u->v_m_eq, net_eff, gc_i, gc_k);
    u->v_m_eq += dt.integ * dt.vm_dt * I_net_r;
  }

  if((noise_type.type == STATE_CLASS(LeabraNoiseSpec)::VM_NOISE) &&
     (noise.type != STATE_CLASS(Random)::NONE) && (net->cycle >= 0)) {
    float ns = u->noise;
    u->v_m += ns;
    u->v_m_eq += ns;
  }

  if(u->v_m < vm_range.min) u->v_m = vm_range.min;
  if(u->v_m > vm_range.max) u->v_m = vm_range.max;
  if(u->v_m_eq < vm_range.min) u->v_m_eq = vm_range.min;
  if(u->v_m_eq > vm_range.max) u->v_m_eq = vm_range.max;
}

*/
